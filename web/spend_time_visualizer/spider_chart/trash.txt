
/*
  
  SpiderChart(Selection selectionToDrawIn, List<CaptionProportionPair> captionProportionPair, int subdivisionCapsCount, num radius, int width, int height){
    
    final int axisCount = captionProportionPair.length;    
    SpiderGrid spiderGrid = new SpiderGrid(axisCount, subdivisionCapsCount, radius);
  }
    /*
    spiderGrid.gridCoordiantes;
    
    
    
    Selection svgSelection = selectionToDrawIn.selectAll("svg");
    svgSelection.data(captionProportionPair);
    svgSelection.attr("width", width);
    svgSelection.attr("height", height);
    
    
    EnteringSelection enterSvgSelection = svgSelection.enter();
    Selection gAppendSelection = enterSvgSelection.append("g");
    gAppendSelection.append("text").attr("class", "title label");
    gAppendSelection.append("text").attr("class", "subtitle label");
    gAppendSelection.append("g").attr("class", "grid");
    gAppendSelection.append("g").attr("class", "axes");
    gAppendSelection.append("path").attr("class", "spider");
    
    Selection gSelection = svgSelection.select("g");
    final int halfWidth = (int)(width/2);
    final int halfHeight = (int)(height/2);
    
    gSelection.attr("transform", "translate(${halfWidth},${halfHeight})");
    
    
    
    
    new LineElement().
    
    var line = d3.svg.line()
        .x(function(d) { return d.x})
        .y(function(d) { return d.y});
    
    Selection gridSelection = gSelection.select('.grid');
    Selection gridlevelSelection = gridSelection.selectAll('.gridlevel');
    gridlevelSelection.data(spiderGrid.gridCoordiantes);
    EnteringSelection gridlevelEnteringSelection = gridlevelSelection.enter();
    var pathSelection = gridlevelEnteringSelection.append("path");
    pathSelection
      ..attr("class", "gridlevel")
      ..style("stroke", "#000")
      ..style("fill", "none")
      ..style("opacity", 0.3)
      ..attr("d", line);
    
    ////console.log(data, scales.domain())
    // select the svg element if it exists
    //var svg = d3.select(this).selectAll("svg").data(captionProportionPair);

        // create the skeleton
        var gEnter = svg.enter().append("svg").append("g");
    gEnter.append("text").attr("class", "title label");
    gEnter.append("text").attr("class", "subtitle label");
    gEnter.append("g").attr("class", "grid");
    gEnter.append("g").attr("class", "axes");
    gEnter.append("path").attr("class", "spider");

    // update the dimensions
    svg .attr("width", width)
    svg .attr("height", height)

    // update the inner dimensions
    var g = svg.select("g")
    .attr("transform", "translate(" + width/2 + "," + height/2 + ")");

    // the grid data, number of ticks
    var gridData = buildAxisGrid(data.length, ticks);

    // add the grid
    var gridEnter = g.select('.grid')
        .selectAll('.gridlevel')
        .data(gridData)
        .enter()
        .append("path").attr("class", "gridlevel")
        .style("stroke", "#000")
        .style("fill", "none")
        .style("opacity", 0.3)
        .attr("d", line);
    
    
    
    var gridEnter = g.select('.grid')
        .selectAll('.gridlevel')
          .data(gridData)
            .enter()
              .append("path").attr("class", "gridlevel")
                .style("stroke", "#000")
                  .style("fill", "none")
                    .style("opacity", 0.3)
                      .attr("d", line);
  }
  
  
  
  
  
  
  /*
  
  int margin = 60;
  int width;
  int height;
  int value;
  int label;
  int countOfSperators;
  String title;
  String subtitle;
  int duration;
  
  num get innerSquareLength => DartMath.min(height, width);
  num get spiderChartDiameter => innerSquareLength - 2;
  num get spiderChartRadius => spiderChartDiameter / 2;
  
// compute an angle
  num angle(num i, collectionLenght) {
    final double pi = DartMath.PI;
    final double twoPi = pi * 2;
    
    
    return i * (twoPi / collectionLenght) +        pi/collectionLenght;
  }
  
  function buildAxisGrid(length, ticks) {
    var min = scales.domain()[0];
    var max = scales.domain()[1] > 0 ? scales.domain()[1] : 1;
    
    
    
    var increase = max/ticks;
    
    
    
    console.log("max: " + max);
    console.log("ticks: " + ticks);
    console.log("increase: " + increase);

    ////console.log("building axis", length, ticks, min, max, increase)
    gridData = []
    for (var i = 0; i <= ticks; i++ ) {
      val = min + i*increase;
      var d = [val];
      console.log("val: " + val);
      console.log("d: " + d);
      
      gridPoints = [];
      for (var j = 0; j <= length; j++) {
        console.log("j: " + j);
        console.log("length: " + length);
        
        gridPoints.push({
          x: calculateX(d, j, length),
          y: calculateY(d, j, length),
        });
        console.log("gridPoints[j].x: " + gridPoints[j].x);
        console.log("gridPoints[j].y: " + gridPoints[j].y);
      };
      
      
      
      gridData.push(gridPoints)
    }

    return gridData;

  }
  
  
  set collectionToVisualize(CaptionProportionPairCollection value){
    
    final CaptionProportionPairCollection collection = value;
    
    final double maxProportion = collection.maxProportion;
    List inputRange = [0, maxProportion];
    List outputRange = [0, spiderChartRadius];

    final Linear linearRemapper = new Linear();
    linearRemapper
      ..domain = inputRange
      ..range = outputRange;
    
    
    

    
    linearRemapper.domain
    
  }
  
  
  
  SpiderChart(){
    
    
    
    final num radius = (Math.min(height,width) - margin) /2;
    
    _scales..domain([0,maxX])
    ..range(0,radius);
    
    //scales.domain.elementAt(index)
    
  }
  
*/
  
